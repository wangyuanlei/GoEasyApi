### 客户端
{
    "clientId":"客户端id",
    "name":"客户端名称",
    "tokenValidation": {
        "enabled": "是否启用token验证，true或false",
        "dataSource": "数据源名称",
        "tableName": "对应的表名",
        "tokenField": "token对应的字段名",
        "userIdField": "对应的user_id字段名"
    },
    "encryption": {
        "inputEnabled": "是否启用入参私钥加密，true或false",
        "outputEnabled": "是否启用出参私钥加密，true或false",
        "algorithm": "使用的加密算法，如RSA",
        "keySize": "密钥长度，如2048",
        "inputPublicKeyPath": "入参公钥验证文件的路径",
        "outputPrivateKeyPath": "出参私钥加密文件的路径"
    },
    "redisCache": {
        "enabled": "是否启用Redis缓存，true或false",
        "host": "Redis服务器地址",
        "port": "Redis服务器端口",
        "password": "Redis密码，如果有的话",
        "db": "使用的Redis数据库编号",
        "keyPrefix": "缓存键前缀",
    },
    "ipFilterMode": "白名单模式或黑名单模式",
    "whitelist": [
        {
            "ip": "允许访问的IP地址",
            "description": "IP地址描述或备注"
        }
    ],
    "blacklist": [
        {
            "ip": "禁止访问的IP地址",
            "description": "IP地址描述或备注"
        }
    ],
    "certificates": [
        {
            "cert": "客户端证书内容",
            "key": "客户端私钥内容",
            "description": "证书描述或备注"
        }
    ],
}
```
这里有几个点需要更改:
1. black/write list要支持限定ip, 限定时间, 限定设备, 只允许Header中带有某个特性才允许访问等, 不是只有一种
2. client这里要记录客户端的设备信息. 
3. 提供log机制/hook机制, 用户每次登录, 都会产生一个供管理员查阅的log
```

### 数据源
{
    "databaseId": "数据源唯一标识符",
    "name": "数据源名称",
    "description": "数据源描述",
    "type": "数据源类型，可选值：'mysql'、'postgresql'、'mssql'、'oracle'、'sqlite'",
    "host": "数据库主机地址",
    "port": "数据库端口号", 
    "database": "数据库名称",
    "username": "数据库用户名",
    "password": "数据库密码",
    "ssl": {
        "enabled": "是否启用SSL连接，true或false",
        "ca": "CA证书路径",
        "cert": "客户端证书路径",
        "key": "客户端私钥路径"
    }
}
```
这里有几个点需要更改:
1. 数据源要提供连接类型, 你这里只包括直接的主机端口连接, 实际上, 还有基于SSH的转接, 基于VPN的转接, 基于代理的转接等等. 未来要赚钱, 应该要允许用户连接到自己的数据库中去. 
2. 数据源不应该是单一的, 应该是一个数组列表, 这样用户在使用的时候, 可以指定读写分离, 或者数据备份机制等等. 这种需求, 个人开发不会用到, 但企业基本都有这个冗余和安全性要求. 
3. 需要提供一个连接池逻辑, 用户在连接的时候, 从连接池得到连接handle, 使用完毕, 放回连接池, 因为创建和销毁一个数据库连接, 本身是一个比较大的资源开销, 没有连接池, 服务器压力会非常大. 
4. 增加额外配置, 包括连接超时, 重连次数, 指定异常log的hook等信息
5. 增加警报系统, 比如指向数据源的所有连接都失效了, 而且无法创建新连接, 就应该发一个警报出来. 
```

### 接口
{
    "id": "接口唯一标识符",
    "clientId": "所属客户端的唯一标识符",
    "databaseId": "数据源唯一标识符",
    "name": "接口名称",
    "path": "接口路径，例如 /api/users",
    "method": "HTTP方法，如GET、POST等",
    "description": "接口描述",
    "requireMsgId": "是否必定验证msg_id，true或false  msg_id作为请求唯一id, 防止重复请求.",
    "cache": {
        "enabled": "是否启用缓存，true或false",
        "duration": "缓存时间，单位为秒",
    },
    "rateLimit": {
        "enabled": "是否启用请求限制，true或false",
        "timeWindow": "时间窗口，单位为秒",
        "maxRequests": "在时间窗口内允许的最大请求数量"
    },
    "sqlContent": "SQL查询语句",
    "params": [
        {
            "name": "参数名称",
            "type": "参数类型，如string、int、boolean等",
            "description": "参数描述",
            "required": "是否为必填参数，true或false",
            "defaultValue": "参数默认值",
            "regex": "参数值的正则表达式验证规则"
        }
    ],
    "type": "接口类型，可选值：'一维数组内容'、'二维数组内容'、'分页请求内容'、'数据库新增, 返回insertId'、'数据库更新 返回bool 执行结果'",
}
```
这里有几个点需要更改:
1. sqlContent只有一个SQL语句不合理, 应该是一个操作列表. 
举个例子, 比如用户的一次安全登录, 可以需要三次SQL操作, 第一次查询用户的信息是否在禁止/允许列表中, 第二次在数据库中查询用户名密码, 第三次在数据库中生成可靠性token, 这三次SQL操作, 才组建成一个用户安全登录的逻辑. 
操作列表中的操作的定义如下:
(1) 操作指的是一次SQL查询, 每次操作, 会绑定一个前置变量筛选器和一个后置结果筛选器, 每次SQL操作的时候, 先执行前置变量筛选器, 再执行SQL语句, 然后执行后置结果筛选器. 
(2) 有一个变量池的概念, 前置变量筛选器或后置结果筛选器, 可以直接对变量进行修改(可以理解为局部变量), 但也可以把变量放到变量池中去(可以理解为全局变量), 这样, 通过变量池, 每一个操作可以把结果传导给后续操作.
(3) 变量池是一个算力成本, 可以为用户本地减少计算量, 并且可以依据此进行收费
(4) 通过操作列表的逻辑方式, 可以搭建很多复杂的业务逻辑, 用户点击某个业务逻辑就可以加入到自己设置的http api接口中去, 而无需自己再手动配置. 我们可以搭建尽可能多的这种逻辑, 实现用户几乎无痕的制作服务端api.
2. 服务端api的接口类型, 你上面罗列的是操作类型, 那个应该放到操作列表中去, 接口类型, 应该指的是直接连接, vpn连接, 代理连接, ssh转接等. 比如说某个企业要制作一套api, 只供自己企业内部使用. 
3. 提供白名单/黑名单机制, 比如限定ip, 限定时间, 限定设备, 只允许Header中带有某个特性才允许访问等. 跟client中的黑白名单不冲突, client中的黑白名单是针对所有操作的, 而api中的黑白名单, 是针对单个操作的. 举个例子, 比如要限定单位里某个用户不允许用某项功能, 可以对他专门限制api. 之后用户的权限, 其实就可以通过这个黑白名单进行细分. 比如说管理员可以用哪些api, 超级管理用哪些api, 普通用户用哪些api, 甚至可以细分到部门, 这个为未来的用户组织细化提供扩展性. 
4. 提供接口混淆机制, 这主要是为了防抓包, 实现接口文本的混淆之后, 用户抓包的时候, 看到的内容是混淆后的内容, 需要解混淆之后才能看到真实内容. 这样可以大量减少一些随机抓包对服务器造成的压力. 当然, 这也是一个收费内容. 
5. 提供模板生成功能, 用户指定某个特定的模板, 比如电商模板, 就自动把电商的后端服务, 批量生成api接口, 这样用户甚至点一下即可, 直接生成一个电商的服务端. 所以, 数据库里要有模板这个表.
6. param的正则表达式验证放到前置变量筛选器中去, 而且, 把默认参数去掉, 默认参数也可以在前置变量筛选器中指定. 
7. rateLimit放到client中去, 因为请求数量限制, 应该是针对所有api的, 而不是某个特定的api. 
8. 要有多个参数入口, 比如url参数, header参数, body参数, query参数, form参数, file参数等等, 都要罗列出来, 这样用户可以自己指定某个参数放在哪里
9. 额外提供一个binaryAPI接口, 可以api中用于文件上传或者下载. 
10. 额外提供一个streamAPI接口, 提供一个流式数据的传输, 当涉及到一个非常耗时操作, 通过streamAPI代替普通API, 不堵塞网络. 
11. 去掉msg_id防重复请求的逻辑, 请求量大到一定程度, msg_id的防重复逻辑其实会失效的, 反而会增加大量逻辑, 除非你开启广泛的写锁, 也就是写msg_id的时候, 锁定操作, 但这会让数据库的整体性能下降, 每次api都要写一个新的msg_id, 锁一次, 成本极高. 而不锁, 就会出现这边写msg_id还没写进入, 那边读msg_id读不到, 系统就认为没有这个msg_id, 所以还是会发生重复请求, 所谓的防重复锁就失效了. 所以, 还是建议去掉msg_id的防重复请求逻辑. 再说, 原本已经在client中限定了请求次数, 根本没必要这里额外做.
```

### 后台管理用户信息
{
    "id": "用户唯一标识符",
    "username": "用户名",
    "password": "密码",
    "description": "用户描述",
    "clientId": "所属客户端的唯一标识符",
    "isAdmin": "是否为管理员，true或false"
}
```
这里有几个点需要更改:
1. 用户id必须为UUID, 而不是自增长模式
2. username改成keys, 里面包括多项, 可能是username, email, phone等
3. password改成verify1, 因为未必是密码, 可能是密码的hash值或者md5值等等
4. 增加一个verify1Term, 密码有效时间, 不指定的话是无限
5. 增加一个verify2, 这个是短期密码, 可以用于账户找回等
6. 增加一个verify2Term, 短期密码有效期, 指定一个时间点, 超过这个时间点, 密码失效
7. 增加一个state, 标注用户的状态, 比如正常和禁用以及删除
8. isAdmin改成type: type里面指定管理员或者普通用户, 因为未来随着管理逻辑增加, 可能还有其它类型
```
